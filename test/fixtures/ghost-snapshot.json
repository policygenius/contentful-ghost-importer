{
  "db": [
    {
      "data": {
        "app_fields": [],
        "app_settings": [],
        "apps": [],
        "client_trusted_domains": [],
        "permissions": [],
        "permissions_apps": [],
        "permissions_roles": [],
        "permissions_users": [],
        "posts": [
          {
            "id": 1,
            "uuid": "905ed83f-5b13-4cbf-9cf8-580eaf91543a",
            "title": "Contentful ruby apps",
            "slug": "contentful-ruby-apps",
            "markdown": "Lately I was playing with the content management service [Contentful](http://contentful.com/) and its ruby gem [contentful.rb](https://github.com/contentful/contentful.rb). In this article you will learn how to kickstart your … contentful … ruby application!\n\n![contentful](/content/images/2014/Aug/127153-88b5dbeb-b37c-44ab-97ed-23e79d3e8518-concept-original-1396987079.jpg)\n\nContentful is a cloud-based and API-driven content management system that allows the user to structure his data via so-called *content models*. Those models are the blueprint for the to-be-stored information. One could think of them as database tables which have specific schemata. Once defined the user can create entries that are instances of the blueprints.\n\nThis article will explain how to create those schemata via Contentful's web GUI. Furthermore it will be described how a user can write and publish entries. Finally you will learn to access those entries easily within a ruby application. The result will be a tiny (read-only) blog system.\n\n## Update\n\nI wrote another post about contentful ruby apps, which introduces some additional helpers and fixes some caveats with the following approach. [You can find it here](/even-more-contentful-ruby-apps/).\n\n## Content models\n\nAs described, content models are the blueprints for your actual data. To keep things simple we will create two basic blog entities, which are connected with each other: A model **blog_post** and a model **tag**. The relationship between is a many-to-many association, meaning that a blog post can have multiple tags and a tag can contain multiple blog posts.\n\n### The content model <span style=\"font-weight: 400\">blog_post</span>\n\nOur upcoming blog post will contain the following fields:\n\n* A mandatory **headline** which is represented as *symbol*. \n* A mandatory **content** which is represented as *text*.\n* A mandatory **publishing date** which is represented as *date/time*.\n* An optional set of **tags** with a data type validation for *tag*. \n\n![The content model blog_post](/content/images/2014/Aug/content-model-blog-post-1.png)\n\nAn example blog post representation would look like this:\n\n```language-javascript\n{\n  \"sys\": {\n    /* meta data */\n  },\n  \"fields\": {\n    \"headline\": \"contentful ruby apps\",\n    \"content\": \"Lately I was playing with the content management service [Contentful](http://contentful.com/) and its ruby gem [contentful.rb](https://github.com/contentful/contentful.rb). In this article you will learn how to kickstart your … contentful … ruby application!\\n\\n\",\n    \"publishedAt\": \"2014-08-19T22:00:00+02:00\",\n    \"tags\": [ { \"sys\": { /* meta data */ } } ]\n  }\n}\n```\n\n### The content model <span style=\"font-weight: 400\">tag</span>\n\nThe tag model will be as simple as possible and just contain:\n\n* a mandatory **name** which is represented as *symbol*.\n\n![The content model tag](/content/images/2014/Aug/content-model-tag-1.png)\n\n\nAn example tag representation would look like this:\n\n```language-javascript\n{\n  \"sys\": {\n\t/* meta data */\n  },\n  \"fields\": {\n    \"name\": \"ruby\"\n  }\n}\n```\n\n### Some words about data types\n\nIn Contentful you will find a whole bunch of data types which are coming with different features and pitfalls. The previously stated ones have the following meanings:\n\n* A **symbol** is a short string that can be used for filtered searches. Symbols can be used to do strict equality checks. Maximum length is 256.\n* A **text** can contain huge textual content in which you might want to fuzzy search. A strict equality check cannot be done. Maximum length is 50,000.\n* A **date/time** comes with a handy calendar widget which allows you to choose a date.\n* A **set of entries** can reference one or many other elements and can furthermore be validated against certain constraints. One of them is a data type.\n\n\n## Talking ruby ...\n\nThe upcoming ruby application will use sinatra and the contentful gem. In order to structure the models and to make additions in contentful an ease, we will define a superclass which handles the whole communication with contentful and provides handy, ActiveRecord-esque helper methods. Furthermore every content model will get its own class representation and inherit from that superclass.\n\n### Getting started\n\nToo keep things short I will just assume some knowledge about ruby and sinatra and post a short gist for the application's scaffold:\n\n```language-bash\nmkdir contentful_blog\ncd contentful_blog\nbundle init\necho 'gem \"activesupport\"' >> Gemfile\necho 'gem \"contentful\"' >> Gemfile\necho 'gem \"i18n\"' >> Gemfile\necho 'gem \"sinatra\"' >> Gemfile\nbundle\nmkdir models\nmkdir views\n```\n\n### Accessing the data\n\n#### ContentModel\nThe most important class of our application is `models/content_model.rb` which act as superclass for the Contentful companions. Besides taking care of the actual API calls (via the contentful.rb gem) it will also provide handy methods to do full-text searches or to find entries by certain fields. Furthermore you will be able to use finder methods that are based on the field names of the content model.\n\nSo here we are:\n\n```language-ruby\nrequire \"contentful\"\n\nclass ContentModel < Contentful::Entry\n  class << self\n    def entry_mapping\n      @entry_mapping ||= superclass.descendants.map do |klass|\n        [klass::CONTENT_TYPE_ID, klass]\n      end.to_h\n    end\n\n    def delivery_client\n      @delivery_client ||= Contentful::Client.new(\n        access_token:    ENV.fetch(\"CONTENTFUL_ACCESS_TOKEN\"),\n        space:           ENV.fetch(\"CONTENTFUL_SPACE_ID\"),\n        dynamic_entries: :auto,\n        entry_mapping:   entry_mapping\n      )\n    end\n\n    def content_type\n      entry_mapping.invert[self]\n    end\n\n    def all(options = {})\n      locale  = options.delete(:locale) || I18n.locale\n      options = options.reverse_merge(\n        \"content_type\" => content_type,\n        \"locale\"       => locale\n      )\n\n      delivery_client.entries options\n    end\n\n    def first(options = {})\n      all(options.merge(\"limit\" => 1)).first\n    end\n\n    def full_text_search(needle)\n      first(\"query\" => needle)\n    end\n\n    def method_missing(method_name, needle, options={})\n      field_name = method_name.to_s.match(/^find_by_(.+)/)\n\n      if field_name\n        field_name = \"fields.#{field_name[1].camelize(:lower)}\"\n        first(options.merge(field_name => needle))\n      else\n        super\n      end\n    end\n  end\nend\n```\n\n#### ContentModel children\n\nAs the `ContentModel` already takes care of the core functionality, each child of that class can focus on their specific domain and might define associations or domain specific helper methods. One thing that needs to be defined for every child class is the constant `CONTENT_MODEL_ID`, though. Here is how an example looks like:\n\n```language-ruby\nclass ExampleContentModel < ContentModel\n  CONTENT_TYPE_ID = \"a-nice-id\"\nend\n```\n\nYou can find the ID of the content models within the web GUI of Contentful. Just open the tab **Content Model** and one of the models afterwards. On the top right you will find a button called **Info** that will open a drawer with meta information about the content type. The **id** is what you are looking for. Just copy and paste it into your model and you are good to go.\n\n![Meta information of the blog post model](/content/images/2014/Aug/content-type-meta-information.png)\n\n#### BlogPost\n\nThe only logic the blog post has to handle is to encode and decode a slug. That feature will be used for generating corresponding url paths. Furthermore we will specify an association to the tags:\n\n```language-ruby\nclass BlogPost < ContentModel\n  CONTENT_TYPE_ID = \"id-of-the-blog-post-model\"\n\n  def self.from_slug(slug)\n    find_by_headline(slug.gsub(\"-\", \" \"))\n  end\n\n  def slug\n    fields[:headline].gsub(\" \", \"-\")\n  end\n\n  def tags\n    fields[:tags]\n  end\nend\n```\n\nPlease notice that the method `from_slug` calls a custom finder method `find_by_headline`.\n\n#### Tag\n\nThe tag itself could in theory have a whole bunch of interesting methods, but to keep things simple it will just inherit from the superclass and define the needed content type id:\n\n```language-ruby\nclass Tag < ContentModel\n  CONTENT_TYPE_ID = \"id-of-the-tag-model\"\nend\n```\n\nOne possible method would be a finder for associated blog posts.\n\n### Please take the stage, mister!\n\nThe sinatra application is pretty simple, though there is one tiny detail which might be good to know and that is the I18n handling. I hooked `active_support/core_ext` into my app and set the `I18n.default_locale` to `en-US` because that is the default locale of a Contentful space:\n\n```language-ruby\nrequire \"active_support/core_ext\"\nrequire \"sinatra\"\n\nset :root, File.dirname(__FILE__)\nset :server, \"webrick\"\n\nconfigure do\n  I18n.default_locale = \"en-US\"\n\n  # load the content_model first and afterwards the other models\n  require File.join(settings.root, \"models\", \"content_model.rb\")\n  Dir[File.join(settings.root, \"models\", \"*.rb\")].each { |file| require file }\nend\n\nget \"/\" do\n  erb :index, locals: { posts: BlogPost.all }\nend\n\nget \"/:id\" do\n  erb :show, locals: { post: BlogPost.from_slug(params[:id]) }\nend\n```\n\n### Uhm, where is the view?\n\nI will skip the details about the view's implementation and instead direct the interested user to the relevant Github pages:\n\n[The post listing page](https://github.com/sdepold/contentful_blog/blob/master/views/index.erb)\n![The post listing page](/content/images/2014/Aug/blog-post-listing-1.png)\n\n[The post detail page](https://github.com/sdepold/contentful_blog/blob/master/views/show.erb)\n![The post detail page](/content/images/2014/Aug/blog-post-details-1.png)\n\n\n## Famous last words\n\nThe complete application [can be found on github](https://github.com/sdepold/contentful_blog). In order to start it, you will need a Contentful account as well as a space with the described content models. Before running the application you need to exchange the content model's ids within `blog_post.rb` and `tag.rb`. Once thats done you can run the application via:\n\n```\nbundle install\nCONTENTFUL_ACCESS_TOKEN=985174a630cf3203f578e747250bd9a9a9b6250e0a0be61367c2e9338b82d983 CONTENTFUL_SPACE_ID=svq072ikci2q bundle exec ruby app.rb\n```\n\nYou should now be able to open [http://localhost:4567](http://localhost:4567) :-)\n\n### Access token? Space ID? \n \nThe space id can be found either in the url of the web GUI (it is the string after `spaces/`) or in the space settings where it states it next to `key`. The access token can futhermore be obtained from the API tab. Just open the tab, click on `API Keys` within the delivery api column and create an API key. Once thats done you should stare at the access token.\n\n## Links\n\n* [Github repository](https://github.com/sdepold/contentful_blog/tree/v1)\n* [Contentful](https://www.contentful.com)\n* [contentful.rb](https://github.com/contentful/contentful.rb)\n* [Follow-up post](/even-more-contentful-ruby-apps/)\n",
            "html": "<p>Lately I was playing with the content management service <a href=\"http://contentful.com/\">Contentful</a> and its ruby gem <a href=\"https://github.com/contentful/contentful.rb\">contentful.rb</a>. In this article you will learn how to kickstart your … contentful … ruby application!</p>\n\n<p><img src=\"/content/images/2014/Aug/127153-88b5dbeb-b37c-44ab-97ed-23e79d3e8518-concept-original-1396987079.jpg\" alt=\"contentful\" /></p>\n\n<p>Contentful is a cloud-based and API-driven content management system that allows the user to structure his data via so-called <em>content models</em>. Those models are the blueprint for the to-be-stored information. One could think of them as database tables which have specific schemata. Once defined the user can create entries that are instances of the blueprints.</p>\n\n<p>This article will explain how to create those schemata via Contentful's web GUI. Furthermore it will be described how a user can write and publish entries. Finally you will learn to access those entries easily within a ruby application. The result will be a tiny (read-only) blog system.</p>\n\n<h2 id=\"update\">Update</h2>\n\n<p>I wrote another post about contentful ruby apps, which introduces some additional helpers and fixes some caveats with the following approach. <a href=\"/even-more-contentful-ruby-apps/\">You can find it here</a>.</p>\n\n<h2 id=\"contentmodels\">Content models</h2>\n\n<p>As described, content models are the blueprints for your actual data. To keep things simple we will create two basic blog entities, which are connected with each other: A model <strong>blog_post</strong> and a model <strong>tag</strong>. The relationship between is a many-to-many association, meaning that a blog post can have multiple tags and a tag can contain multiple blog posts.</p>\n\n<h3 id=\"thecontentmodelspanstylefontweight400blog_postspan\">The content model <span style=\"font-weight: 400\">blog_post</span></h3>\n\n<p>Our upcoming blog post will contain the following fields:</p>\n\n<ul>\n<li>A mandatory <strong>headline</strong> which is represented as <em>symbol</em>. </li>\n<li>A mandatory <strong>content</strong> which is represented as <em>text</em>.</li>\n<li>A mandatory <strong>publishing date</strong> which is represented as <em>date/time</em>.</li>\n<li>An optional set of <strong>tags</strong> with a data type validation for <em>tag</em>. </li>\n</ul>\n\n<p><img src=\"/content/images/2014/Aug/content-model-blog-post-1.png\" alt=\"The content model blog_post\" /></p>\n\n<p>An example blog post representation would look like this:</p>\n\n<pre><code class=\"language-javascript\">{\n  \"sys\": {\n    /* meta data */\n  },\n  \"fields\": {\n    \"headline\": \"contentful ruby apps\",\n    \"content\": \"Lately I was playing with the content management service [Contentful](http://contentful.com/) and its ruby gem [contentful.rb](https://github.com/contentful/contentful.rb). In this article you will learn how to kickstart your … contentful … ruby application!\\n\\n\",\n    \"publishedAt\": \"2014-08-19T22:00:00+02:00\",\n    \"tags\": [ { \"sys\": { /* meta data */ } } ]\n  }\n}\n</code></pre>\n\n<h3 id=\"thecontentmodelspanstylefontweight400tagspan\">The content model <span style=\"font-weight: 400\">tag</span></h3>\n\n<p>The tag model will be as simple as possible and just contain:</p>\n\n<ul>\n<li>a mandatory <strong>name</strong> which is represented as <em>symbol</em>.</li>\n</ul>\n\n<p><img src=\"/content/images/2014/Aug/content-model-tag-1.png\" alt=\"The content model tag\" /></p>\n\n<p>An example tag representation would look like this:</p>\n\n<pre><code class=\"language-javascript\">{\n  \"sys\": {\n    /* meta data */\n  },\n  \"fields\": {\n    \"name\": \"ruby\"\n  }\n}\n</code></pre>\n\n<h3 id=\"somewordsaboutdatatypes\">Some words about data types</h3>\n\n<p>In Contentful you will find a whole bunch of data types which are coming with different features and pitfalls. The previously stated ones have the following meanings:</p>\n\n<ul>\n<li>A <strong>symbol</strong> is a short string that can be used for filtered searches. Symbols can be used to do strict equality checks. Maximum length is 256.</li>\n<li>A <strong>text</strong> can contain huge textual content in which you might want to fuzzy search. A strict equality check cannot be done. Maximum length is 50,000.</li>\n<li>A <strong>date/time</strong> comes with a handy calendar widget which allows you to choose a date.</li>\n<li>A <strong>set of entries</strong> can reference one or many other elements and can furthermore be validated against certain constraints. One of them is a data type.</li>\n</ul>\n\n<h2 id=\"talkingruby\">Talking ruby ...</h2>\n\n<p>The upcoming ruby application will use sinatra and the contentful gem. In order to structure the models and to make additions in contentful an ease, we will define a superclass which handles the whole communication with contentful and provides handy, ActiveRecord-esque helper methods. Furthermore every content model will get its own class representation and inherit from that superclass.</p>\n\n<h3 id=\"gettingstarted\">Getting started</h3>\n\n<p>Too keep things short I will just assume some knowledge about ruby and sinatra and post a short gist for the application's scaffold:</p>\n\n<pre><code class=\"language-bash\">mkdir contentful_blog  \ncd contentful_blog  \nbundle init  \necho 'gem \"activesupport\"' &gt;&gt; Gemfile  \necho 'gem \"contentful\"' &gt;&gt; Gemfile  \necho 'gem \"i18n\"' &gt;&gt; Gemfile  \necho 'gem \"sinatra\"' &gt;&gt; Gemfile  \nbundle  \nmkdir models  \nmkdir views  \n</code></pre>\n\n<h3 id=\"accessingthedata\">Accessing the data</h3>\n\n<h4 id=\"contentmodel\">ContentModel</h4>\n\n<p>The most important class of our application is <code>models/content_model.rb</code> which act as superclass for the Contentful companions. Besides taking care of the actual API calls (via the contentful.rb gem) it will also provide handy methods to do full-text searches or to find entries by certain fields. Furthermore you will be able to use finder methods that are based on the field names of the content model.</p>\n\n<p>So here we are:</p>\n\n<pre><code class=\"language-ruby\">require \"contentful\"\n\nclass ContentModel &lt; Contentful::Entry  \n  class &lt;&lt; self\n    def entry_mapping\n      @entry_mapping ||= superclass.descendants.map do |klass|\n        [klass::CONTENT_TYPE_ID, klass]\n      end.to_h\n    end\n\n    def delivery_client\n      @delivery_client ||= Contentful::Client.new(\n        access_token:    ENV.fetch(\"CONTENTFUL_ACCESS_TOKEN\"),\n        space:           ENV.fetch(\"CONTENTFUL_SPACE_ID\"),\n        dynamic_entries: :auto,\n        entry_mapping:   entry_mapping\n      )\n    end\n\n    def content_type\n      entry_mapping.invert[self]\n    end\n\n    def all(options = {})\n      locale  = options.delete(:locale) || I18n.locale\n      options = options.reverse_merge(\n        \"content_type\" =&gt; content_type,\n        \"locale\"       =&gt; locale\n      )\n\n      delivery_client.entries options\n    end\n\n    def first(options = {})\n      all(options.merge(\"limit\" =&gt; 1)).first\n    end\n\n    def full_text_search(needle)\n      first(\"query\" =&gt; needle)\n    end\n\n    def method_missing(method_name, needle, options={})\n      field_name = method_name.to_s.match(/^find_by_(.+)/)\n\n      if field_name\n        field_name = \"fields.#{field_name[1].camelize(:lower)}\"\n        first(options.merge(field_name =&gt; needle))\n      else\n        super\n      end\n    end\n  end\nend  \n</code></pre>\n\n<h4 id=\"contentmodelchildren\">ContentModel children</h4>\n\n<p>As the <code>ContentModel</code> already takes care of the core functionality, each child of that class can focus on their specific domain and might define associations or domain specific helper methods. One thing that needs to be defined for every child class is the constant <code>CONTENT_MODEL_ID</code>, though. Here is how an example looks like:</p>\n\n<pre><code class=\"language-ruby\">class ExampleContentModel &lt; ContentModel  \n  CONTENT_TYPE_ID = \"a-nice-id\"\nend  \n</code></pre>\n\n<p>You can find the ID of the content models within the web GUI of Contentful. Just open the tab <strong>Content Model</strong> and one of the models afterwards. On the top right you will find a button called <strong>Info</strong> that will open a drawer with meta information about the content type. The <strong>id</strong> is what you are looking for. Just copy and paste it into your model and you are good to go.</p>\n\n<p><img src=\"/content/images/2014/Aug/content-type-meta-information.png\" alt=\"Meta information of the blog post model\" /></p>\n\n<h4 id=\"blogpost\">BlogPost</h4>\n\n<p>The only logic the blog post has to handle is to encode and decode a slug. That feature will be used for generating corresponding url paths. Furthermore we will specify an association to the tags:</p>\n\n<pre><code class=\"language-ruby\">class BlogPost &lt; ContentModel  \n  CONTENT_TYPE_ID = \"id-of-the-blog-post-model\"\n\n  def self.from_slug(slug)\n    find_by_headline(slug.gsub(\"-\", \" \"))\n  end\n\n  def slug\n    fields[:headline].gsub(\" \", \"-\")\n  end\n\n  def tags\n    fields[:tags]\n  end\nend  \n</code></pre>\n\n<p>Please notice that the method <code>from_slug</code> calls a custom finder method <code>find_by_headline</code>.</p>\n\n<h4 id=\"tag\">Tag</h4>\n\n<p>The tag itself could in theory have a whole bunch of interesting methods, but to keep things simple it will just inherit from the superclass and define the needed content type id:</p>\n\n<pre><code class=\"language-ruby\">class Tag &lt; ContentModel  \n  CONTENT_TYPE_ID = \"id-of-the-tag-model\"\nend  \n</code></pre>\n\n<p>One possible method would be a finder for associated blog posts.</p>\n\n<h3 id=\"pleasetakethestagemister\">Please take the stage, mister!</h3>\n\n<p>The sinatra application is pretty simple, though there is one tiny detail which might be good to know and that is the I18n handling. I hooked <code>active_support/core_ext</code> into my app and set the <code>I18n.default_locale</code> to <code>en-US</code> because that is the default locale of a Contentful space:</p>\n\n<pre><code class=\"language-ruby\">require \"active_support/core_ext\"  \nrequire \"sinatra\"\n\nset :root, File.dirname(__FILE__)  \nset :server, \"webrick\"\n\nconfigure do  \n  I18n.default_locale = \"en-US\"\n\n  # load the content_model first and afterwards the other models\n  require File.join(settings.root, \"models\", \"content_model.rb\")\n  Dir[File.join(settings.root, \"models\", \"*.rb\")].each { |file| require file }\nend\n\nget \"/\" do  \n  erb :index, locals: { posts: BlogPost.all }\nend\n\nget \"/:id\" do  \n  erb :show, locals: { post: BlogPost.from_slug(params[:id]) }\nend  \n</code></pre>\n\n<h3 id=\"uhmwhereistheview\">Uhm, where is the view?</h3>\n\n<p>I will skip the details about the view's implementation and instead direct the interested user to the relevant Github pages:</p>\n\n<p><a href=\"https://github.com/sdepold/contentful_blog/blob/master/views/index.erb\">The post listing page</a>\n<img src=\"/content/images/2014/Aug/blog-post-listing-1.png\" alt=\"The post listing page\" /></p>\n\n<p><a href=\"https://github.com/sdepold/contentful_blog/blob/master/views/show.erb\">The post detail page</a>\n<img src=\"/content/images/2014/Aug/blog-post-details-1.png\" alt=\"The post detail page\" /></p>\n\n<h2 id=\"famouslastwords\">Famous last words</h2>\n\n<p>The complete application <a href=\"https://github.com/sdepold/contentful_blog\">can be found on github</a>. In order to start it, you will need a Contentful account as well as a space with the described content models. Before running the application you need to exchange the content model's ids within <code>blog_post.rb</code> and <code>tag.rb</code>. Once thats done you can run the application via:</p>\n\n<pre><code>bundle install  \nCONTENTFUL_ACCESS_TOKEN=985174a630cf3203f578e747250bd9a9a9b6250e0a0be61367c2e9338b82d983 CONTENTFUL_SPACE_ID=svq072ikci2q bundle exec ruby app.rb  \n</code></pre>\n\n<p>You should now be able to open <a href=\"http://localhost:4567\">http://localhost:4567</a> :-)</p>\n\n<h3 id=\"accesstokenspaceid\">Access token? Space ID?</h3>\n\n<p>The space id can be found either in the url of the web GUI (it is the string after <code>spaces/</code>) or in the space settings where it states it next to <code>key</code>. The access token can futhermore be obtained from the API tab. Just open the tab, click on <code>API Keys</code> within the delivery api column and create an API key. Once thats done you should stare at the access token.</p>\n\n<h2 id=\"links\">Links</h2>\n\n<ul>\n<li><a href=\"https://github.com/sdepold/contentful_blog/tree/v1\">Github repository</a></li>\n<li><a href=\"https://www.contentful.com\">Contentful</a></li>\n<li><a href=\"https://github.com/contentful/contentful.rb\">contentful.rb</a></li>\n<li><a href=\"/even-more-contentful-ruby-apps/\">Follow-up post</a></li>\n</ul>",
            "image": null,
            "featured": 0,
            "page": 0,
            "status": "published",
            "language": "en_US",
            "meta_title": null,
            "meta_description": null,
            "author_id": 1,
            "created_at": "2014-08-19T17:45:03.000Z",
            "created_by": 1,
            "updated_at": "2014-09-24T13:01:36.000Z",
            "updated_by": 1,
            "published_at": "2014-08-19T15:45:03.000Z",
            "published_by": 1
          }
        ],
        "posts_tags": [
          {
            "id": 256,
            "post_id": 1,
            "tag_id": 2,
            "sort_order": 2
          },
          {
            "id": 257,
            "post_id": 1,
            "tag_id": 3,
            "sort_order": 1
          },
          {
            "id": 258,
            "post_id": 1,
            "tag_id": 4,
            "sort_order": 0
          }
        ],
        "roles": [],
        "roles_users": [],
        "settings": [],
        "tags": [
          {
            "id": 2,
            "uuid": "9d1ecb67-b3b8-41f4-8109-f0f54a2bf7ff",
            "name": "content management",
            "slug": "content-management",
            "description": null,
            "image": null,
            "hidden": 0,
            "parent_id": null,
            "meta_title": null,
            "meta_description": null,
            "created_at": "2014-08-19T18:13:01.000Z",
            "created_by": 1,
            "updated_at": "2014-08-19T18:13:01.000Z",
            "updated_by": 1
          },
          {
            "id": 3,
            "uuid": "3e337600-3d1a-4f37-bb5a-500061faa660",
            "name": "ruby",
            "slug": "ruby",
            "description": null,
            "image": null,
            "hidden": 0,
            "parent_id": null,
            "meta_title": null,
            "meta_description": null,
            "created_at": "2014-08-19T18:13:01.000Z",
            "created_by": 1,
            "updated_at": "2014-08-19T18:13:01.000Z",
            "updated_by": 1
          },
          {
            "id": 4,
            "uuid": "f52dc6f8-b674-4fb4-9c44-02241e8ad58a",
            "name": "service",
            "slug": "service",
            "description": null,
            "image": null,
            "hidden": 0,
            "parent_id": null,
            "meta_title": null,
            "meta_description": null,
            "created_at": "2014-08-19T18:13:01.000Z",
            "created_by": 1,
            "updated_at": "2014-08-19T18:13:01.000Z",
            "updated_by": 1
          }
        ],
        "users": [
          {
            "id": 1,
            "uuid": "4506e208-1859-478e-814f-a0cabffb92ab",
            "name": "Sascha Depold",
            "slug": "sascha-depold",
            "password": "$2a$10$mTHCaZMtob5symP6QlzyNeEnWs.GTgeJP3eL6NJV9JT9dmLI7ITJW",
            "email": "sascha@depold.com",
            "image": "//www.gravatar.com/avatar/f30479a06db175157387334e03766420?d=404&s=250",
            "cover": null,
            "bio": null,
            "website": null,
            "location": null,
            "accessibility": null,
            "status": "active",
            "language": "en_US",
            "meta_title": null,
            "meta_description": null,
            "last_login": "2015-11-03T19:22:33.000Z",
            "created_at": "2014-08-19T17:45:03.000Z",
            "created_by": 1,
            "updated_at": "2015-11-03T19:22:33.000Z",
            "updated_by": 1,
            "tour": null
          }
        ]
      }
    }
  ]
}
